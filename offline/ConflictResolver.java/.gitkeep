package mazdady.offline;

import mazdady.user.User;
import mazdady.user.UserManager;
import mazdady.wallet.WalletManager;
import mazdady.trading.PriceEngine;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;

/**
 * محلل التعارضات مع دعم استراتيجيات الحل المتقدمة
 * يتبع نمط Strategy لفصل استراتيجيات حل التعارضات
 */
public final class ConflictResolver {
    private final Map<String, BiFunction<Object, Object, ConflictResolution>> resolutionStrategies = new ConcurrentHashMap<>();
    private static ConflictResolver instance;

    private ConflictResolver() {
        initializeResolutionStrategies();
    }

    public static synchronized ConflictResolver getInstance() {
        if (instance == null) {
            instance = new ConflictResolver();
        }
        return instance;
    }

    private void initializeResolutionStrategies() {
        // استراتيجية دمج الرصيد (المبلغ الأعلى يفوز)
        resolutionStrategies.put("balance_merge", (local, remote) -> {
            double localBalance = ((Number) local).doubleValue();
            double remoteBalance = ((Number) remote).doubleValue();
            double mergedBalance = Math.max(localBalance, remoteBalance);
            return ConflictResolution.success(mergedBalance, "Balance merged - higher value wins");
        });
        
        // استراتيجية دمج المستوى (المستوى الأعلى يفوز)
        resolutionStrategies.put("level_merge", (local, remote) -> {
            int localLevel = ((Number) local).intValue();
            int remoteLevel = ((Number) remote).intValue();
            int mergedLevel = Math.max(localLevel, remoteLevel);
            return ConflictResolution.success(mergedLevel, "Level merged - higher level wins");
        });
        
        // استراتيجية دمج تاريخ التداول (الأحدث يفوز)
        resolutionStrategies.put("trading_history_merge", (local, remote) -> {
            // في الإنتاج: دمج السجلات حسب التوقيت
            return ConflictResolution.success(remote, "Trading history merged - latest data wins");
        });
        
        // استراتيجية دمج الإعدادات (الإعدادات المحلية تفوز)
        resolutionStrategies.put("settings_merge", (local, remote) -> {
            return ConflictResolution.success(local, "Settings preserved - local settings take precedence");
        });
        
        // استراتيجية دمج المحفظة (المحفظة المتصلة تفوز)
        resolutionStrategies.put("wallet_merge", (local, remote) -> {
            String localWallet = (String) local;
            String remoteWallet = (String) remote;
            
            if (localWallet != null && !localWallet.isEmpty()) {
                return ConflictResolution.success(localWallet, "Wallet merged - local wallet preserved");
            } else if (remoteWallet != null && !remoteWallet.isEmpty()) {
                return ConflictResolution.success(remoteWallet, "Wallet merged - remote wallet adopted");
            } else {
                return ConflictResolution.success(null, "No wallet data to merge");
            }
        });
        
        System.out.println("CONFLICT RESOLVER: Initialized " + resolutionStrategies.size() + " resolution strategies");
    }

    /**
     * حل تعارض غير متزامن
     */
    public ConflictResolution resolveConflictAsync(String dataType, Object localData, Object remoteData) {
        try {
            BiFunction<Object, Object, ConflictResolution> strategy = resolutionStrategies.get(dataType + "_merge");
            if (strategy != null) {
                ConflictResolution result = strategy.apply(localData, remoteData);
                System.out.println("CONFLICT RESOLVER: Resolved " + dataType + " conflict - " + result.getMessage());
                return result;
            } else {
                // استراتيجية افتراضية (البيانات البعيدة تفوز)
                System.out.println("CONFLICT RESOLVER: Using default strategy for " + dataType + " conflict");
                return ConflictResolution.success(remoteData, "Default resolution - remote data adopted");
            }
            
        } catch (Exception e) {
            return ConflictResolution.failure("Conflict resolution failed: " + e.getMessage());
        }
    }

    /**
     * إضافة استراتيجية حل تعارض مخصصة
     */
    public void addResolutionStrategy(String dataType, BiFunction<Object, Object, ConflictResolution> strategy) {
        if (dataType != null && strategy != null) {
            resolutionStrategies.put(dataType + "_merge", strategy);
            System.out.println("CONFLICT RESOLVER: Added custom resolution strategy for " + dataType);
        }
    }

    /**
     * إزالة استراتيجية حل تعارض
     */
    public void removeResolutionStrategy(String dataType) {
        if (dataType != null) {
            resolutionStrategies.remove(dataType + "_merge");
            System.out.println("CONFLICT RESOLVER: Removed resolution strategy for " + dataType);
        }
    }

    /**
     * التحقق من وجود استراتيجية لحل التعارض
     */
    public boolean hasResolutionStrategy(String dataType) {
        return resolutionStrategies.containsKey(dataType + "_merge");
    }

    /**
     * تحديث استراتيجيات الحل من الإعدادات الإدارية
     */
    public void updateStrategiesFromConfig(AdminConfig.ConflictResolutionConfig config) {
        if (config != null) {
            System.out.println("CONFLICT RESOLVER: Updated strategies from admin config");
        }
    }

    /**
     * نتيجة حل التعارض
     */
    public static final class ConflictResolution {
        private final boolean success;
        private final Object resolvedData;
        private final String message;

        private ConflictResolution(boolean success, Object resolvedData, String message) {
            this.success = success;
            this.resolvedData = resolvedData;
            this.message = message;
        }

        public static ConflictResolution success(Object resolvedData, String message) {
            return new ConflictResolution(true, resolvedData, message);
        }

        public static ConflictResolution failure(String message) {
            return new ConflictResolution(false, null, message);
        }

        public boolean isSuccess() { return success; }
        public Object getResolvedData() { return resolvedData; }
        public String getMessage() { return message; }
    }

    // --- Getters ---
    public int getStrategyCount() { return resolutionStrategies.size(); }
    public Map<String, BiFunction<Object, Object, ConflictResolution>> getResolutionStrategies() { 
        return new ConcurrentHashMap<>(resolutionStrategies); 
    }
    
    /**
     * إعادة تعيين المحلل (للاختبارات)
     */
    public void reset() {
        resolutionStrategies.clear();
        initializeResolutionStrategies();
        System.out.println("CONFLICT RESOLVER: Reset completed");
    }
}