package mazdady.dev;

import mazdady.admin.AdminConfig;
import mazdady.security.SecurityMonitor;

import java.io.File;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;

/**
 * محلل الكود مع دعم التحليل الثابت المتقدم
 * يتبع نمط Strategy لفصل قواعد التحليل
 */
public final class CodeAnalyzer {
    private final ConcurrentHashMap<String, AnalysisRule> rules = new ConcurrentHashMap<>();
    private final SecurityMonitor securityMonitor;
    private static CodeAnalyzer instance;

    private CodeAnalyzer(SecurityMonitor securityMonitor) {
        this.securityMonitor = securityMonitor;
        initializeRules();
    }

    public static synchronized CodeAnalyzer getInstance(SecurityMonitor securityMonitor) {
        if (instance == null) {
            instance = new CodeAnalyzer(securityMonitor);
        }
        return instance;
    }

    private void initializeRules() {
        rules.put("NULL_CHECK", new NullCheckRule());
        rules.put("SECURITY_RULE", new SecurityRule());
        rules.put("PERFORMANCE_RULE", new PerformanceRule());
        rules.put("NAMING_CONVENTION", new NamingConventionRule());
        rules.put("THREAD_SAFETY", new ThreadSafetyRule());
        rules.put("MEMORY_LEAK", new MemoryLeakRule());
        rules.put("RESOURCE_MANAGEMENT", new ResourceManagementRule());
        rules.put("ERROR_HANDLING", new ErrorHandlingRule());
        rules.put("CODE_DUPLICATION", new CodeDuplicationRule());
        rules.put("DEPRECATED_USAGE", new DeprecatedUsageRule());
        
        System.out.println("CODE ANALYZER: Initialized with " + rules.size() + " analysis rules");
    }

    /**
     * تحليل مشروع كامل غير متزامن
     */
    public CompletableFuture<AnalysisReport> analyzeProjectAsync(String projectPath) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                AnalysisReport report = new AnalysisReport();
                File projectDir = new File(projectPath);
                
                if (!projectDir.exists() || !projectDir.isDirectory()) {
                    return AnalysisReport.failure("Invalid project path: " + projectPath);
                }
                
                analyzeDirectory(projectDir, report);
                
                System.out.println("CODE ANALYZER: Project analysis completed - " + 
                                 report.getIssues().size() + " issues found");
                
                return report;
                
            } catch (Exception e) {
                return AnalysisReport.failure("Project analysis failed: " + e.getMessage());
            }
        });
    }

    private void analyzeDirectory(File directory, AnalysisReport report) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    analyzeDirectory(file, report);
                } else if (file.getName().endsWith(".java")) {
                    analyzeFile(file, report);
                }
            }
        }
    }

    private void analyzeFile(File file, AnalysisReport report) {
        try {
            String content = readFileContent(file);
            String filePath = file.getAbsolutePath();
            
            for (AnalysisRule rule : rules.values()) {
                rule.analyze(content, filePath, report);
            }
            
        } catch (Exception e) {
            report.addIssue("FILE_READ_ERROR", file.getPath(), "Failed to read file: " + e.getMessage());
        }
    }

    private String readFileContent(File file) throws Exception {
        // في الإنتاج: قراءة محتوى الملف
        return "// Mock file content for " + file.getName();
    }

    /**
     * تحديث قواعد التحليل من الإعدادات الإدارية
     */
    public void updateRulesFromConfig(AdminConfig.CodeAnalysisConfig config) {
        if (config == null) return;
        
        // في الإنتاج: تحديث القواعد حسب الإعدادات الإدارية
        System.out.println("CODE ANALYZER: Rules updated from admin config");
    }

    /**
     * قاعدة تحليل
     */
    @FunctionalInterface
    public interface AnalysisRule {
        void analyze(String content, String filePath, AnalysisReport report);
    }

    // --- قواعد التحليل ---
    private static final class NullCheckRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("== null") || content.contains("!= null")) {
                report.addIssue("NULL_CHECK", filePath, "Direct null checks found - consider using Optional");
            }
        }
    }

    private static final class SecurityRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("System.out.println") && !filePath.contains("dev/")) {
                report.addIssue("SECURITY_RULE", filePath, "System.out.println found in production code");
            }
        }
    }

    private static final class PerformanceRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("new Thread(")) {
                report.addIssue("PERFORMANCE_RULE", filePath, "Direct Thread creation - use ExecutorService");
            }
        }
    }

    private static final class NamingConventionRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (filePath.contains(" ")) {
                report.addIssue("NAMING_CONVENTION", filePath, "File path contains spaces");
            }
        }
    }

    private static final class ThreadSafetyRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("ArrayList<") && content.contains("Runnable")) {
                report.addIssue("THREAD_SAFETY", filePath, "ArrayList used in multi-threaded context - consider CopyOnWriteArrayList");
            }
        }
    }

    private static final class MemoryLeakRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("Context") && content.contains("static")) {
                report.addIssue("MEMORY_LEAK", filePath, "Static Context reference may cause memory leak");
            }
        }
    }

    private static final class ResourceManagementRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("FileInputStream") && !content.contains("try-with-resources")) {
                report.addIssue("RESOURCE_MANAGEMENT", filePath, "Resource not managed properly - use try-with-resources");
            }
        }
    }

    private static final class ErrorHandlingRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("catch (Exception e)") && !content.contains("e.printStackTrace()")) {
                report.addIssue("ERROR_HANDLING", filePath, "Generic exception handling without logging");
            }
        }
    }

    private static final class CodeDuplicationRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            // في الإنتاج: استخدام خوارزمية للكشف عن التكرار
            if (content.lines().count() > 500) {
                report.addIssue("CODE_DUPLICATION", filePath, "Large file may contain duplicated code");
            }
        }
    }

    private static final class DeprecatedUsageRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("@Deprecated")) {
                report.addIssue("DEPRECATED_USAGE", filePath, "Deprecated code usage detected");
            }
        }
    }

    /**
     * تقرير التحليل
     */
    public static final class AnalysisReport {
        private final ConcurrentHashMap<String, Issue> issues = new ConcurrentHashMap<>();
        private volatile boolean success = true;
        private volatile String message = "Analysis completed";

        public static AnalysisReport failure(String message) {
            AnalysisReport report = new AnalysisReport();
            report.success = false;
            report.message = message;
            return report;
        }

        public void addIssue(String ruleName, String filePath, String description) {
            String issueId = ruleName + "_" + filePath.hashCode();
            issues.put(issueId, new Issue(ruleName, filePath, description));
        }

        public ConcurrentHashMap<String, Issue> getIssues() {
            return new ConcurrentHashMap<>(issues);
        }

        public boolean isSuccess() { return success; }
        public String getMessage() { return message; }
        public int getIssueCount() { return issues.size(); }
        
        public String getSummary() {
            return "CODE ANALYSIS: " + issues.size() + " issues found\n" +
                   issues.values().stream()
                       .map(Issue::toString)
                       .reduce("", (a, b) -> a + "\n" + b);
        }

        /**
         * مشكلة في الكود
         */
        public static final class Issue {
            private final String ruleName;
            private final String filePath;
            private final String description;

            public Issue(String ruleName, String filePath, String description) {
                this.ruleName = ruleName;
                this.filePath = filePath;
                this.description = description;
            }

            @Override
            public String toString() {
                return "[" + ruleName + "] " + filePath + ": " + description;
            }

            // Getters
            public String getRuleName() { return ruleName; }
            public String getFilePath() { return filePath; }
            public String getDescription() { return description; }
        }
    }
}