package mazdady.dev;

import java.io.File;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Predicate;

/**
 * Ù…Ø­Ù„Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø«Ø§Ø¨Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
 * ÙŠØªØ¨Ø¹ Ù†Ù…Ø· Strategy Ù„ÙØµÙ„ Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØªØ­Ù„ÙŠÙ„
 */
public final class CodeAnalyzer {
    private final CopyOnWriteArrayList<AnalysisRule> rules = new CopyOnWriteArrayList<>();
    private static final CodeAnalyzer INSTANCE = new CodeAnalyzer();

    private CodeAnalyzer() {
        initializeRules();
    }

    public static CodeAnalyzer getInstance() {
        return INSTANCE;
    }

    private void initializeRules() {
        rules.add(new NullCheckRule());
        rules.add(new SecurityRule());
        rules.add(new PerformanceRule());
        rules.add(new NamingConventionRule());
    }

    /**
     * ØªØ­Ù„ÙŠÙ„ Ù…Ø´Ø±ÙˆØ¹ ÙƒØ§Ù…Ù„ ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†
     */
    public CompletableFuture<AnalysisReport> analyzeProjectAsync(String projectPath) {
        return CompletableFuture.supplyAsync(() -> {
            AnalysisReport report = new AnalysisReport();
            File projectDir = new File(projectPath);
            analyzeDirectory(projectDir, report);
            return report;
        });
    }

    private void analyzeDirectory(File directory, AnalysisReport report) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    analyzeDirectory(file, report);
                } else if (file.getName().endsWith(".java")) {
                    analyzeFile(file, report);
                }
            }
        }
    }

    private void analyzeFile(File file, AnalysisReport report) {
        try {
            String content = readFileContent(file);
            for (AnalysisRule rule : rules) {
                rule.analyze(content, file.getPath(), report);
            }
        } catch (Exception e) {
            report.addIssue("FileReadError", file.getPath(), e.getMessage());
        }
    }

    private String readFileContent(File file) throws Exception {
        // ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬: Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù
        return "// Mock file content";
    }

    /**
     * Ù‚Ø§Ø¹Ø¯Ø© ØªØ­Ù„ÙŠÙ„
     */
    @FunctionalInterface
    public interface AnalysisRule {
        void analyze(String content, String filePath, AnalysisReport report);
    }

    /**
     * ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØ­Ù„ÙŠÙ„
     */
    public static final class AnalysisReport {
        private final CopyOnWriteArrayList<Issue> issues = new CopyOnWriteArrayList<>();

        public void addIssue(String ruleName, String filePath, String description) {
            issues.add(new Issue(ruleName, filePath, description));
        }

        public String getSummary() {
            return String.format(
                "ğŸ” CODE ANALYSIS: %d issues found\n%s",
                issues.size(),
                issues.isEmpty() ? "" : issues.stream()
                    .map(Issue::toString)
                    .collect(java.util.stream.Collectors.joining("\n"))
            );
        }
    }

    /**
     * Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ÙƒÙˆØ¯
     */
    public static final class Issue {
        private final String ruleName;
        private final String filePath;
        private final String description;

        public Issue(String ruleName, String filePath, String description) {
            this.ruleName = ruleName;
            this.filePath = filePath;
            this.description = description;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s: %s", ruleName, filePath, description);
        }
    }

    // --- Ù‚ÙˆØ§Ø¹Ø¯ ØªØ­Ù„ÙŠÙ„ Ù…Ø®ØµØµØ© ---
    private static final class NullCheckRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("== null") || content.contains("!= null")) {
                report.addIssue("NullCheckRule", filePath, "Direct null checks found - use Optional");
            }
        }
    }

    private static final class SecurityRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("System.out.println") && !filePath.contains("dev/")) {
                report.addIssue("SecurityRule", filePath, "System.out.println found in production code");
            }
        }
    }

    private static final class PerformanceRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            if (content.contains("new Thread(")) {
                report.addIssue("PerformanceRule", filePath, "Direct Thread creation - use ExecutorService");
            }
        }
    }

    private static final class NamingConventionRule implements AnalysisRule {
        @Override
        public void analyze(String content, String filePath, AnalysisReport report) {
            // ÙÙŠ Ø§Ù„Ø¥Ù†ØªØ§Ø¬: Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªÙØ§Ù‚ÙŠØ§Øª Ø§Ù„ØªØ³Ù…ÙŠØ©
            if (filePath.contains(" ")) {
                report.addIssue("NamingConventionRule", filePath, "File path contains spaces");
            }
        }
    }
}